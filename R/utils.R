#' Save an R object as data or results as CSV, or RDS files
#'
#' @param x A tabular R object
#' @param folder Folder in which to write the file. If the resulting path does not exist, a new directory will be generated.
#' @param formats Formats in which to write the files. Must be at least one of 'csv', or 'rds'
#' @param .sep Path separator, takes "/" by default
save_files <- function(x,
                       folder,
                       file_name = deparse(substitute(x)),
                       formats = c("csv", "rds"),
                       .sep = "/") 
{
    # check arguments
    if (!all(formats %in% c("csv", "rds"))) {
        cli::cli_abort("formats must be 'csv' or 'rds'")
    }
    
    # create directories if missing
    file_paths <- glue::glue("{folder}{.sep}{file_name}.{formats}")
    
    if (length(formats) > 1) {
        
        dirs <- glue::glue("{folder}{.sep}{formats}")
        dirs_exist <- dir.exists(dirs)
        
        if (any(!dirs_exist)) {
            
            which_missing <- formats[which(!dirs_exist)]
            missing_dir <- glue::glue("{folder}{.sep}{which_missing}{.sep}")
            
            invisible(purrr::map(missing_dir, dir.create))
            
            cli::cli_alert_warning("Created {.path {missing_dir}}")
            
            file_paths <-
                glue::glue("{folder}{.sep}{formats}{.sep}{file_name}.{formats}")
            
        }
    }
    
    # save files
    if ("csv" %in% formats) {
        write.csv(flatten_columns(x), 
                  file_paths[grepl(".csv", file_paths)], 
                  row.names = FALSE)
    }
    
    if ("rds" %in% formats) {
        saveRDS(x, file_paths[grepl(".rds", file_paths)])
    }
    
    if (interactive()) cli::cli_alert_success("Saved to {.path {folder}}")
}

#' Transform any list column in a data frame to collapsed character vector
#'
#' @param x A data frame
flatten_columns <- function(x) {
    mutate(x, 
           across(
               where(is.list),
               function(x) {
                   out <- purrr::map(x, function(x) {
                       paste0(x, collapse = ", ")
                   })
                   unlist(out)
               }
           )
    )
}

#' Dictionary for predictor names
#' 
#' @param data Dataset of responses as generated by the [get_responses()] function
#' @returns A named character vector
get_vars_dict <- function(responses) {
    var.names <- c("b_Intercept[1]",
                   "b_Intercept[2]",
                   "b_n_phon_std",
                   "b_age_std",
                   "b_exposure_std",
                   "b_lv_std",
                   "b_exposure_std:lv_std",
                   "b_age_std:exposure_std",
                   "b_age_std:lv_std",
                   "b_age_std:exposure_std:lv_std")
    
    var.labels <- c(
        "Comprehension and Production",
        "Comprehension",
        glue::glue("Length (+1 SD, {round(sd(responses$n_phon), 2)} phonemes)"),
        glue::glue("Age (+1 SD, {round(sd(responses$age), 2)} months)"),
        glue::glue("Exposure (+1 SD, {round(sd(responses$exposure), 2)})"),
        glue::glue("Cognateness (+1 SD, {round(sd(responses$lv), 2)})"),
        "Exposure \u00d7 Cognateness",
        "Age \u00d7 Exposure",
        "Age \u00d7 Cognateness",
        "Age \u00d7 Exposure \u00d7 Cognateness"
    )
    
    vars_dict <- var.labels
    names(vars_dict) <- var.names
    
    return(vars_dict)
}

#' Dictionary for predictor names
#' 
#' @param data Dataset of responses as generated by the [get_responses()] function
#' @returns A named character vector
get_vars_dict_doe <- function(responses) {
    var.names <- c("b_Intercept[1]", 
                   "b_Intercept[2]",
                   "b_age_std", 
                   "b_n_phon_std",
                   "b_freq_std",
                   "b_doe_std",
                   "b_lv_std", 
                   "b_age_std:doe_std",
                   "b_doe_std:lv_std", 
                   "b_age_std:lv_std",
                   "b_age_std:doe_std:lv_std")
    
    var.labels <- c(
        "Comprehension and Production",
        "Comprehension",
        glue::glue("Age (+1 SD, {round(sd(responses$age), 2)}, months)"),
        glue::glue("Phonemes (+1 SD, {round(sd(responses$n_phon), 2)} phonemes)"),
        glue::glue("Frequency (+1 SD, {round(sd(responses$freq), 2)})"),
        glue::glue("DoE (+1 SD, {round(sd(responses$doe), 2)})"),
        glue::glue("Cognateness (+1 SD, {round(sd(responses$lv), 2)})"),
        "Age \u00d7 DoE",
        "DoE \u00d7 Cognateness",
        "Age \u00d7 Cognateness",
        "Age \u00d7 DoE \u00d7 Cognateness"
    )
    
    vars_dict <- var.labels
    names(vars_dict) <- var.names
    
    return(vars_dict)
}

#' Syllabify phonological transcriptions in X-SAMPA formats
#' 
#' @param x A character string with a phonological transcription in X-SAMPA.
#' @param .sep A vector of character strings indicating the characters that will be used to separate syllables. Takes `"\\."` and `"\\\""` by default.
#' 
#' @return A vector of characters in which each element is a syllable.
syllabify_xsampa <- function(x, .sep = c("\\.", "\\\"")) {
    syll <- strsplit(x, split = paste0(.sep, collapse = "|"))
    syll <- lapply(syll, function(x) x[x != ""])
    return(syll)
}



