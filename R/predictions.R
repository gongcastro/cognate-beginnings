#' Generate dataset with posterior predictions from a brmsfit model
#'
#' @param model A brmsfit object
#' @param data Data with which the model was fist, containing the original variables
#' @param group Group for which posterior predictions will be generated. If NULL (default), posterior predictions will be generated for fixed effect. If 'te', predictions will be generated for translation equivalents. If 'id', predictions will be generated for participants.
#' @param levels If group is 'id' or 'te', specific levels (translation equivalents or participants) can be specified. If NULL (default), posterior predictions are generated for all levels of the grouping variable.
#' @inheritParams marginaleffects::datagrid
generate_newdata <- function(model,
                             data,
                             group = NULL,
                             levels = NULL,
                             ...) {
    # some checks
    if (!is.null(group)) {
        if (!(group %in% c("te", "id")) | length(group) > 1) {
            cli_abort("group must be one of 'te' or 'id")
        }
    }
    
    # make sure that all levels exist in the dataset
    if (!is.null(levels)) {
        levels_in_data <- levels %in% data[[group]]
        if (!all(levels_in_data)) {
            missing_levels <- paste0(levels[!levels_in_data], collapse = ", ")
            cli_abort("Level {missing_levels} in {.field {group}} is missing")
        }
    }
    
    # data frame with prediction combinations
    if (is.null(group)) {
        nd <- datagrid(model = model, te = NA, id = NA, ...)
    } else {
        # expand predictor levels in data frame to generate predictions
        if (group == "te") {
            # if group is "te", generate predictions for each level of `te`
            nd <- datagrid(model = model, te = levels, id = NA, ...) |>
                select(-lv_std) |>
                left_join(distinct(data, te, lv_std))
        }
        if (group == "id") {
            # expand predictor levels in data frame to generate predictions
            nd <- datagrid(model = model, id = levels, te = NA, ...) |>
                select(-age_std) |>
                left_join(distinct(data, id, age_std))
        }
    }
    
    return(nd)
}


#' Generate posterior predictions for fixed effects brmsfit model via \code{marginaleffects::predictions}
#'
#' @param model A brmsfit object
#' @param data Data with the desired combination of levels of the predictors for which to generate posterior predictions, as generated by \code{generate_newdata}
#' @inheritParams marginaleffects::datagrid
posterior_predictions <- function(model, data, ...) {
    # generate data for predictions
    newdata <- generate_newdata(model, data, ...)
    
    # use marginaleffects to get posterior means
    predictions <- predictions(
        model,
        newdata = newdata,
        re_formula = NA,
        ndraws = 25,
        vcov = FALSE,
    ) |>
        posteriordraws() |> # so that each draw gets a row
        as_tibble() |>
        clean_names() |> 
        filter(group != "No") |> 
        pivot_wider(
            id_cols = any_of(c("drawid", colnames(newdata))),
            names_from = group,
            values_from = draw
        ) |>
        mutate(`Understands` = `Understands and Says` + `Understands`) |>
        pivot_longer(
            c(`Understands`, `Understands and Says`),
            names_to = "group",
            values_to = "draw"
        ) |>
        select(
            any_of(colnames(newdata)),
            .category = group,
            .draw = drawid,
            .value = draw
        )
    
    # save predictions as Parquet file
    save_files(predictions, folder = "results/predictions")
    
    return(predictions)
}

#' Generate posterior predictions for fixed effects brmsfit model via \code{marginaleffects::predictions}
#'
#' @param model A brmsfit object
#' @param data Data with the desired combination of levels of the predictors for which to generate posterior predictions, as generated by \code{generate_newdata}
#' @param group Group level for which posterior predictions are generated. Takes 'te' or 'id' as values.
#' @param ... Additional arguments passed to \code{marginaleffects::predictions}
posterior_predictions_re <- function(model, data, group, ...) {
    if (!(group %in% c("id", "te"))) {
        cli_abort("group must be 'id' or 'te'")
    }
    # generate data for predictions
    newdata <- generate_newdata(model, data, group, ...)
    
    # use marginaleffects to get posterior means
    preds <- predictions(
        model,
        newdata = newdata,
        re_formula = as.formula(paste0("~1|", group)),
        vcov = FALSE,
        ndraws = 25
    ) |>
        posteriordraws() |> # so that each draw gets a row
        as_tibble() |>
        clean_names() |>
        filter(group != "No") |>
        pivot_wider(
            id_cols = c(drawid, age_std, lv_std, exposure_std, te, id),
            names_from = group,
            values_from = draw
        ) |>
        mutate(`Understands` = `Understands and Says` + `Understands`) |>
        pivot_longer(
            c(`Understands`, `Understands and Says`),
            names_to = "group",
            values_to = "draw"
        ) |>
        mutate(
            age = age_std * sd(data$age) + mean(data$age),
            exposure = factor(
                exposure_std,
                levels = unique(newdata$exposure_std),
                labels = c("Exposure: -1 SD",
                           "Exposure: mean",
                           "Exposure: +1 SD"),
                ordered = TRUE
            )
        )
    
    if (group == "te") {
        predictions_te <- preds
        
        # export results
        save_files(predictions_te, folder = "results/predictions")
        
        predictions_re <- predictions_te
    }
    
    if (group == "id") {
        predictions_id <- preds
        
        # export results
        save_files(predictions_id, folder = "results/predictions")
        
        predictions_re <- predictions_id
    }
    
    return(predictions_re)
}
