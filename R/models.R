#' Specify and sample a [brms::brm()] model
#' @param name A character string indicating the name to be assigned to the model
#' @param ... Arguments to be passed to [brms::brm()]
fit_model <- function(name, ...) {
    fit <- brms::brm(...,
        iter = 2000,
        chains = 4,
        init = 0.5,
        seed = 888,
        backend = "cmdstanr",
        file = glue::glue("results/fits/{name}.rds"),
        file_refit = "on_change",
        control = list(
            adapt_delta = 0.9,
            max_treedepth = 15
        ),
        save_model = glue::glue("Stan/{name}.stan")
    )

    return(fit)
}

#' Extract posterior draws of fixed effect coefficients from brmsfit model via [tidybayes::gather_draws()].
#'
#' @param model A brmsfit object
#' @param data Dataset of responses as generated by the [get_responses()] function
#' @param vars_dict Dictionary of variable names, as returned by `get_vars_dict()` or `get_vars_dict_doe()`
#' @param ... Arguments to be passed to [tidybayes::gather_draws()].
get_posterior_draws <- function(model, data, vars_dict, ...) {
    # posterior draws
    posterior_draws <- tidybayes::gather_draws(model, `b_.*`, regex = TRUE) |>
        mutate(
            .variable_name = factor(.variable,
                levels = names(vars_dict),
                labels = vars_dict
            ) |>
                as.character(),
            type = ifelse(
                grepl("Intercept", .variable),
                glue::glue("Intercepts (at {round(mean(data$age, 2))} months)"),
                "Slopes"
            ),
            parameter = ifelse(
                grepl("Intercept", .variable),
                gsub("Intercept \\(|\\)", "", .variable),
                .variable
            )
        ) |>
        select(.variable, .variable_name,
            .type = type,
            .chain, .iteration, .draw, .value
        ) |>
        ungroup()

    save_files(posterior_draws,
        formats = "csv",
        folder = "results/posterior"
    )

    return(posterior_draws)
}

#' Extract posterior draws of fixed effect coefficients from brmsfit model via [bayestesteR::describe_posterior()].
#'
#' @param model A brmsfit object
#' @param data Dataset of responses as generated by the [get_responses()] function
#' @param vars_dict Dictionary of variable names, as returned by `get_vars_dict()` or `get_vars_dict_doe()`
#' @param ... Arguments to be passed to [bayestesteR::describe_posterior()].
get_posterior_summary <- function(model,
                                  data,
                                  vars_dict,
                                  rope_interval = c(lower = -0.1, upper = +0.1),
                                  ...) {
    # posterior draws
    posterior_summary <- tidybayes::gather_draws(model, `b_.*`, regex = TRUE, ...) |>
        tidybayes::median_hdci() |>
        mutate(
            .variable_name = factor(.variable,
                levels = names(vars_dict),
                labels = vars_dict,
                ordered = TRUE
            ),
            type = ifelse(
                grepl("Intercept", .variable),
                glue::glue("Intercepts (at {round(mean(data$age, 2))} months)"),
                "Slopes"
            ),
            parameter = ifelse(
                grepl("Intercept", .variable),
                gsub("Intercept \\(|\\)", "", .variable),
                .variable
            ),
            .rope = get_rope_overlap(.lower, .upper, .rope = rope_interval),
            .rope = ifelse(grepl("Intercept", .variable), NA, .rope)
        ) |>
        arrange(type, .variable_name) |>
        select(.variable, .variable_name,
            .type = type,
            .value, .lower, .upper, .rope
        ) |>
        ungroup()
    
    save_files(posterior_summary, folder = "results/posterior", formats = "csv")

    return(posterior_summary)
}

#' Get model R-hat scores
#'
#' @param model A brmsfit object
#' @param ... Arguments to be passed to [bayesplot::rhat()] and
#' [bayesplot::neff_ratio()].
#'
#' @returns A [tibble::tibble] with three columns:
#' * .variable: parameter names, as returned by [brms::variables()]
#' * .rhat: R-hat (Gelman-Rubin) convergence diagnostic, as returned by
#' [bayesplot::rhat()].
#' * .neff: effective sample size, as returned by [bayesplot::neff_ratio()]
get_model_convergence <- function(model, ...) {
    out <- tibble::tibble(
        .variable = variables(model),
        .rhat = rhat(model, ...),
        .neff = neff_ratio(model, ...)
    )
    
    save_files(out, folder = "results/posterior", formats = "csv")
    
    return(out)
}

#' Get model posterior predictive checks
#'
#' @param model A brmsfit object
#' @param ... Arguments to be passed to [brms::posterior_predict()].
#'
get_model_ppc <- function(model, ...) {
    brms::posterior_predict(model, ndraws = 100, cores = 4)
}

#' Get overlap between an intervals and a ROPE
#'
#' @param .lower A numeric vector indicating the lower limit of the interval to contrasts against the ROPE
#' @param .upper A numeric vector indicating the upper limit of the interval to contrasts against the ROPE
#' @param .rope A numeric vector of length two indicating the limits of the region of practical equivalents against which the interval should be tested
#' @param precision A numeric vector of length one indicating the number of values each interval should be broke down into in order to compute the proportion of overlap
#' @returns A numeric vector of length `length(.lower)` indicating the proportion of overlap between the interval and the ROPE
#'
get_rope_overlap <- function(.lower, .upper, .rope = c(-0.1, 0.1), precision = 1e4) {
    int <- data.frame(.lower, .upper)
    fun <- \(x) approx(x, n = precision, method = "linear")
    int.seq <- purrr::map(apply(int, fun, MARGIN = 1), "y")
    overlap <- purrr::map_dbl(int.seq, \(x) mean((x >= .rope[1]) & x <= .rope[2]))
    return(overlap)
}
