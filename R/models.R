
#' Specify and sample a [brms::brm()] model
#' @param name A character string indicating the name to be assigned to the model
#' @param ... Arguments to be passed to [brms::brm()]
fit_model <- function(name, ...) {
    # we run the model in the background as an RStudio job to keep the console free
    # see R/utils.R
    fit <- brm(...,
               iter = 2000,
               chains = 4,
               init = 0.5,
               seed = 888,
               backend = "cmdstanr",
               file = glue("results/fits/{name}.rds"),
               file_refit = "on_change",
               control = list(adapt_delta = 0.9,
                              max_treedepth = 15),
               save_model = glue("stan/{name}.stan"))
    
    return(fit)
}

#' Extract log-likelihood of brmsfit object or list of brmsfit objects via \code{loo::log_lik}
#' @param x A list of \code{brmsfit} objects that will be compared
#' @param ... Arguments to be passed to \code{log_lik}
get_log_lik <- function(x, ...) {
    # make sure x is a brms fit object or a list of thereof
    if (!all(sapply(x, is.brmsfit))) {
        cli_abort("x must be a brmsfit object or a list of brmsfit objects")
    }
    
    # if x is a single brmsfit object, make it a list (of one element)
    if (is.brmsfit(x)) {
        x <- list(x)
    }
    
    # pre-allocate vectors
    n_models <- length(x)
    log_liks <- vector(mode = "list", length = n_models)
    
    # compute likelihoods
    cli_progress_bar("Computing likelihoods", total = n_models)
    for (i in 1:n_models) {
        log_liks[[i]] <- log_lik(x[[i]], ...)  # compute log-likelihood
        cli_progress_update()
    }
    cli_progress_done()
    
    # keep names if any
    if (!is.null(names(x))) {
        names(log_liks) <- names(x)
    }
    return(log_liks)
}


#' Compute leave-one-out cross-validation of brmsfit object or list of brmsfit objects via \code{loo::loo}
#' @param x A list of log-likelihoods extracted from brmsfit objects using \code{loo:log_lik}
#' @param ... Arguments to be passed to \code{loo}
get_loo <- function(x, ...) {
    # pre-allocate vector
    n_models <- length(x)
    loos <- vector(mode = "list", length = n_models)
    
    # compute loo
    cli_progress_bar("Computing LOOs", total = n_models)
    for (i in 1:n_models) {
        loos[[i]] <- loo(x[[i]], ...)
        cli_progress_update()
    }
    cli_progress_done()
    
    # keep names if any
    if (!is.null(names(x))) {
        names(loos) <- names(x)
    }
    
    return(loos)
}

#' Extract posterior draws of fixed effect coefficients from brmsfit model via \code{tidybayes::gather_draws}.
#' 
#' @param model A brmsfit object
#' @param data Dataset of resposnes as generated by the \code{get_responses} function
#' @param ... Arguments to be passed to \code{tidybayes::gather_draws}
get_posterior_draws <- function(model,
                                data,
                                rope_interval = c(lower = -0.1,
                                                  upper = +0.1),
                                ...) {
    # tidy predictor names
    str_repl <- c(
        "b_Intercept[1]" = "Comprehension and Production",
        "b_Intercept[2]" = "Comprehension",
        "b_age_std" = glue("Age (+1 SD, {round(sd(data$age), 2)}, months)"),
        "b_n_phon_std" = glue("Length (+1 SD, {round(sd(data$n_phon), 2)} phonemes)"),
        "b_exposure_std" = glue("Exposure (+1 SD, {round(sd(data$exposure), 2)})"),
        "b_lv_std" = glue("Cognateness (+1 SD, {percent(sd(data$lv), accuracy = 0.01)})"),
        "b_exposure_std:lv_std" = "Exposure \u00d7 Cognateness",
        "b_age_std:exposure_std" = "Age \u00d7 Exposure",
        "b_age_std:lv_std" = "Age \u00d7 Cognateness",
        "b_age_std:exposure_std:lv_std" = "Age \u00d7 Exposure \u00d7 Cognateness"
    )
    
    # posterior draws
    posterior_draws <- gather_draws(model, `b_.*`, regex = TRUE, ...) |>
        mutate(.variable_name = factor(.variable,
                                       levels = names(str_repl),
                                       labels = str_repl) |>
                   as.character(),
               type = ifelse(str_detect(.variable, "Intercept"),
                             glue("Intercepts (at {round(mean(data$age, 2))} months)"),
                             "Slopes"),
               parameter = ifelse(str_detect(.variable, "Intercept"),
                                  str_remove_all(.variable, "Intercept \\(|\\)"),
                                  .variable)) |>
        select(.variable, .variable_name, .type = type, 
               .chain, .iteration, .draw, .value) |>
        ungroup()
    
    # posterior summary
    posterior_summary <- describe_posterior(model,
                                            test = "rope",
                                            rope_range = rope_interval,
                                            ci_method = "HDI",
                                            ...) |>
        as_tibble() |>
        clean_names() |>
        mutate(.variable_name = factor(
            parameter,
            levels = names(str_repl),
            labels = str_repl) |>
                as.character(),
            type = ifelse(str_detect(parameter, "Intercept"),
                          glue("Intercepts (at {round(mean(data$age, 2))} months)"),
                          "Slopes"),
            parameter = ifelse(str_detect(parameter, "Intercept"),
                               str_remove_all(parameter, "Intercept \\(|\\)"),
                               parameter)) |>
        select(.variable = parameter,
               .variable_name,
               .type = type,
               .median = median,
               .upper = ci_high,
               .lower = ci_low,
               .rope_overlap = rope_percentage) |>
        ungroup()
    
    # make list with posterior
    posterior <- list()
    posterior$summary <- posterior_summary
    posterior$draws <- posterior_draws
    
    # export draws
    save_files(posterior_draws, folder = "results/posterior")
    
    return(posterior)
}

#' Extract posterior draws of random effect coefficients (a.k.a. group-level coefficients) from brmsfit model via [tidybayes::gather_draws()].
#' 
#' @param model A brmsfit object
#' @param data Dataset of responses as generated by the [get_responses()].
#' @param ... Arguments to be passed to [tidybayes::gather_draws()].
get_posterior_draws_re <- function(model) {
    # get posterior draws of dixed effects
    posterior_draws <- gather_draws(model, `b_.*`, regex = TRUE) |>
        rename(.value_fixed = .value) |>
        mutate(
            .type = case_when(
                .variable == "b_Intercept[2]" ~ "Comprehension",
                .variable == "b_Intercept[1]" ~ "Comprehension and Production",
                TRUE ~ "Both"
            ),
            .variable = str_remove_all(.variable, "b_|\\[1\\]|\\[2\\]")
        )
    
    # get posterior draws of random effects
    posterior_draws_re <- gather_draws(model, r_te[te, term]) |>
        ungroup() |>
        select(-.variable) |>
        rename(.variable = term) |>
        left_join(posterior_draws) |>
        mutate(.value_rescaled = .value + .value_fixed)
    
    # export draws
    save_files(posterior_draws_re, folder = "results/posterior")
    
    return(posterior_draws_re)
}