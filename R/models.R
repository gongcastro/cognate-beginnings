#' Specify and sample a [brms::brm()] model
#' @param name A character string indicating the name to be assigned to the model
#' @param ... Arguments to be passed to [brms::brm()]
fit_model <- function(name, ...) {
    fit <- brms::brm(...,
                     iter = 2000,
                     chains = 4,
                     init = 0.5,
                     seed = 888,
                     backend = "cmdstanr",
                     file = glue::glue("results/fits/{name}.rds"),
                     file_refit = "never",
                     control = list(
                         adapt_delta = 0.9,
                         max_treedepth = 15
                     ),
                     save_model = glue::glue("Stan/{name}.stan")
    )
    
    return(fit)
}

#' Extract posterior draws of fixed effect coefficients from brmsfit model via [tidybayes::gather_draws()].
#'
#' @param model A brmsfit object
#' @param data Dataset of responses as generated by the [get_responses()] function
#' @param vars_dict Dictionary of variable names, as returned by `get_vars_dict()` or `get_vars_dict_doe()`
#' @param ... Arguments to be passed to [tidybayes::gather_draws()].
get_posterior_draws <- function(model, data, vars_dict, ...) {
    # posterior draws
    posterior_draws <- tidybayes::gather_draws(model, `b_.*`, regex = TRUE) |>
        mutate(
            .variable_name = factor(.variable,
                                    levels = names(vars_dict),
                                    labels = vars_dict
            ) |>
                as.character(),
            type = ifelse(
                grepl("Intercept", .variable),
                glue::glue("Intercepts (at {round(mean(data$age, 2))} months)"),
                "Slopes"
            ),
            parameter = ifelse(
                grepl("Intercept", .variable),
                gsub("Intercept \\(|\\)", "", .variable),
                .variable
            )
        ) |>
        select(.variable, .variable_name,
               .type = type,
               .chain, .iteration, .draw, .value
        ) |>
        ungroup()
    
    save_files(posterior_draws,
               formats = "csv",
               folder = "results/posterior"
    )
    
    return(posterior_draws)
}

#' Extract posterior draws of fixed effect coefficients from brmsfit model via [bayestesteR::describe_posterior()].
#'
#' @param model A brmsfit object
#' @param data Dataset of responses as generated by the [get_responses()] function
#' @param vars_dict Dictionary of variable names, as returned by `get_vars_dict()` or `get_vars_dict_doe()`
#' @param ... Arguments to be passed to [bayestesteR::describe_posterior()].
get_posterior_summary <- function(model,
                                  data,
                                  vars_dict,
                                  rope_interval = c(lower = -0.1, upper = +0.1),
                                  ...) {
    # posterior draws
    posterior_summary <- tidybayes::gather_draws(model, `b_.*`, regex = TRUE, ...) |>
        tidybayes::median_hdci() |>
        mutate(
            .variable_name = factor(.variable,
                                    levels = names(vars_dict),
                                    labels = vars_dict,
                                    ordered = TRUE
            ),
            type = ifelse(
                grepl("Intercept", .variable),
                glue::glue("Intercepts (at {round(mean(data$age, 2))} months)"),
                "Slopes"
            ),
            parameter = ifelse(
                grepl("Intercept", .variable),
                gsub("Intercept \\(|\\)", "", .variable),
                .variable
            ),
            .rope = get_rope_overlap(.lower, .upper, .rope = rope_interval),
            .rope = ifelse(grepl("Intercept", .variable), NA, .rope)
        ) |>
        arrange(type, .variable_name) |>
        select(.variable, .variable_name,
               .type = type,
               .value, .lower, .upper, .rope
        ) |>
        ungroup()
    
    return(posterior_summary)
}

#' Extract posterior draws of random effect coefficients from brmsfit model via [tidybayes::gather_draws()].
#'
#' @param model A brmsfit object
#' @param vars_dict Dictionary of variable names, as returned by `get_vars_dict()` or `get_vars_dict_doe()`
#' @param ... Arguments to be passed to [tidybayes::gather_draws()].
get_posterior_re <- function(model, vars_dict, ...)
{
    fixed_effects <- model |> 
        tidybayes::gather_draws(`b_.*`, regex = TRUE, ...) |> 
        filter(!grepl("Intercept", .variable)) |> 
        tidybayes::median_hdci() |> 
        mutate(.variable_name = factor(.variable,
                                       levels = names(vars_dict),
                                       labels = vars_dict,
                                       ordered = TRUE)) |>  
        select(.variable, .variable_name,
               .value_fixed = .value,
               .lower_fixed = .lower,
               .upper_fixed = .upper)
    
    posterior_re <- model |> 
        tidybayes::gather_draws(r_id[id, .param], ...) |>
        filter(!grepl("Intercept", .param)) |> 
        tidybayes::median_hdci() |> 
        select(-.variable) |> 
        rename(.variable = .param) |>
        mutate(.variable = paste0("b_", .variable)) |> 
        inner_join(fixed_effects,
                   relationship = "many-to-many",
                   by = join_by(.variable)) |>
        mutate(.variable_name = factor(.variable,
                                       levels = names(vars_dict), 
                                       labels = vars_dict, 
                                       ordered = TRUE), 
               .value = (.value_fixed + .value) / 4) |>       
        select(id, .variable, .variable_name, 
               .value, .lower, .upper, 
               .value_fixed, .lower_fixed, .upper_fixed)
    
    return(posterior_re)
}

#' Get model R-hat scores
#'
#' @param model A brmsfit object
#' @param ... Arguments to be passed to [bayesplot::rhat()] and
#' [bayesplot::neff_ratio()].
#'
#' @returns A [tibble::tibble] with three columns:
#' * .variable: parameter names, as returned by [brms::variables()]
#' * .rhat: R-hat (Gelman-Rubin) convergence diagnostic, as returned by
#' [bayesplot::rhat()].
#' * .neff: effective sample size, as returned by [bayesplot::neff_ratio()]
get_model_convergence <- function(model, ...) {
    tibble::tibble(
        .variable = variables(model),
        .rhat = rhat(model, ...),
        .neff = neff_ratio(model, ...)
    )
}

#' Get model posterior predictive checks
#'
#' @param model A brmsfit object
#' @param ... Arguments to be passed to [brms::posterior_predict()].
#'
get_model_ppc <- function(model, ...) {
    brms::posterior_predict(model, ndraws = 100, cores = 4)
}

#' Get overlap between an intervals and a ROPE
#'
#' @param .lower A numeric vector indicating the lower limit of the interval to contrasts against the ROPE
#' @param .upper A numeric vector indicating the upper limit of the interval to contrasts against the ROPE
#' @param .rope A numeric vector of length two indicating the limits of the region of practical equivalents against which the interval should be tested
#' @param precision A numeric vector of length one indicating the number of values each interval should be broke down into in order to compute the proportion of overlap
#' @returns A numeric vector of length `length(.lower)` indicating the proportion of overlap between the interval and the ROPE
#'
get_rope_overlap <- function(.lower, .upper, .rope = c(-0.1, 0.1), precision = 1e4) {
    int <- data.frame(.lower, .upper)
    fun <- \(x) approx(x, n = precision, method = "linear")
    int.seq <- purrr::map(apply(int, fun, MARGIN = 1), "y")
    overlap <- purrr::map_dbl(int.seq, \(x) mean((x >= .rope[1]) & x <= .rope[2]))
    return(overlap)
}
